"""
Exploit runner using Foundry.

Compiles and executes exploit code in sandboxed environment using Forge.
"""

import subprocess
import json
import re
import logging
from typing import Dict, Optional
from pathlib import Path
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn

console = Console()
logger = logging.getLogger(__name__)


class ExploitRunner:
    """
    Compiles and runs exploit code using Foundry (Forge).

    Executes exploits in isolated fork environment and captures results.
    """

    def __init__(self, foundry_project_dir: Optional[str] = None):
        """
        Initialize exploit runner.

        Args:
            foundry_project_dir: Path to Foundry project directory
        """
        if foundry_project_dir:
            self.project_dir = Path(foundry_project_dir)
        else:
            # Use default foundry_project directory
            self.project_dir = Path(__file__).parent / 'foundry_project'

        self.src_dir = self.project_dir / 'src'
        self.test_dir = self.project_dir / 'test'

        # Create directories if they don't exist
        self.src_dir.mkdir(parents=True, exist_ok=True)
        self.test_dir.mkdir(parents=True, exist_ok=True)

        # Check if Forge is available
        self._check_forge_available()

    def _check_forge_available(self):
        """Check if Forge is installed and available."""
        try:
            result = subprocess.run(
                ['forge', '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                console.print(f"[green]Forge available: {result.stdout.split()[1]}[/green]")
            else:
                console.print("[yellow]Warning: Forge may not be properly installed[/yellow]")
        except FileNotFoundError:
            console.print("[red]Forge not found! Install Foundry:[/red]")
            console.print("curl -L https://foundry.paradigm.xyz | bash && foundryup")

    def compile_exploit(self, exploit_code: str, output_name: str = 'FlawVerifier') -> Dict:
        """
        Compile exploit Solidity code.

        Args:
            exploit_code: Solidity source code
            output_name: Output contract name

        Returns:
            Compilation result dictionary
        """
        # Save exploit code to src directory
        exploit_file = self.src_dir / f'{output_name}.sol'

        with open(exploit_file, 'w') as f:
            f.write(exploit_code)

        console.print(f"[yellow]Compiling {output_name}.sol...[/yellow]")

        try:
            # Run forge build
            result = subprocess.run(
                ['forge', 'build', '--root', str(self.project_dir)],
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0:
                console.print("[green]Compilation successful[/green]")
                return {
                    'success': True,
                    'contract_name': output_name,
                    'file_path': str(exploit_file),
                    'stdout': result.stdout
                }
            else:
                console.print("[red]Compilation failed[/red]")
                console.print(result.stderr)
                return {
                    'success': False,
                    'error': result.stderr,
                    'contract_name': output_name
                }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'Compilation timeout (60s)',
                'contract_name': output_name
            }
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'contract_name': output_name
            }

    def run_exploit(
        self,
        contract_name: str,
        fork_url: str,
        target_address: Optional[str] = None,
        initial_balance: str = '100'
    ) -> Dict:
        """
        Run exploit in forked environment.

        Args:
            contract_name: Name of the exploit contract
            fork_url: URL of the forked blockchain
            target_address: Optional target contract address
            initial_balance: Initial ETH balance for exploit contract

        Returns:
            Exploit execution result
        """
        console.print(f"[yellow]Running exploit: {contract_name}[/yellow]")

        # Create a test file for the exploit
        test_code = self._generate_test_file(contract_name, target_address, initial_balance)
        test_file = self.test_dir / f'{contract_name}.t.sol'

        with open(test_file, 'w') as f:
            f.write(test_code)

        try:
            with Progress(
                SpinnerColumn(),
                TextColumn("[progress.description]{task.description}"),
                console=console,
                transient=True
            ) as progress:
                progress.add_task(description="Executing exploit...", total=None)

                # Run forge test
                result = subprocess.run(
                    [
                        'forge', 'test',
                        '--match-path', str(test_file),
                        '--fork-url', fork_url,
                        '-vvv',  # Very verbose for debugging
                        '--root', str(self.project_dir)
                    ],
                    capture_output=True,
                    text=True,
                    timeout=120
                )

            # Parse test output
            parsed_result = self._parse_test_output(result.stdout, result.stderr)

            return {
                'success': result.returncode == 0,
                'contract_name': contract_name,
                'test_passed': parsed_result['test_passed'],
                'profit': parsed_result['profit'],
                'gas_used': parsed_result['gas_used'],
                'stdout': result.stdout,
                'stderr': result.stderr,
                'parsed_output': parsed_result
            }

        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'Exploit execution timeout (120s)',
                'contract_name': contract_name
            }
        except Exception as e:
            logger.error(f"Exploit execution failed: {e}")
            return {
                'success': False,
                'error': str(e),
                'contract_name': contract_name
            }

    def _generate_test_file(
        self,
        contract_name: str,
        target_address: Optional[str],
        initial_balance: str
    ) -> str:
        """
        Generate Foundry test file for the exploit.

        Args:
            contract_name: Exploit contract name
            target_address: Target contract address
            initial_balance: Initial ETH balance

        Returns:
            Test file source code
        """
        target_addr = target_address or '0x0000000000000000000000000000000000000000'

        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../src/{contract_name}.sol";

contract {contract_name}Test is Test {{
    {contract_name} public exploit;
    address public target = {target_addr};

    function setUp() public {{
        // Give this contract some initial ETH
        vm.deal(address(this), {initial_balance} ether);

        // Deploy exploit contract
        exploit = new {contract_name}(target);

        // Fund exploit contract
        vm.deal(address(exploit), {initial_balance} ether);
    }}

    function testExploit() public {{
        uint256 initialBalance = address(exploit).balance;

        // Execute exploit
        bool success = exploit.verify{{value: 1 ether}}();

        uint256 finalBalance = address(exploit).balance;
        uint256 profit = finalBalance > initialBalance ? finalBalance - initialBalance : 0;

        // Log results
        emit log_named_uint("Initial Balance", initialBalance);
        emit log_named_uint("Final Balance", finalBalance);
        emit log_named_uint("Profit (wei)", profit);
        emit log_named_uint("Profit (ether)", profit / 1 ether);

        // Exploit should succeed and make profit
        assertTrue(success || profit > 0, "Exploit failed");
    }}
}}
'''

    def _parse_test_output(self, stdout: str, stderr: str) -> Dict:
        """
        Parse Forge test output to extract results.

        Args:
            stdout: Standard output
            stderr: Standard error

        Returns:
            Parsed results dictionary
        """
        result = {
            'test_passed': False,
            'profit': 0,
            'gas_used': 0,
            'traces': []
        }

        # Check if test passed
        if '[PASS]' in stdout or 'testExploit' in stdout:
            result['test_passed'] = True

        # Extract profit
        profit_match = re.search(r'Profit \(wei\):\s*(\d+)', stdout)
        if profit_match:
            result['profit'] = int(profit_match.group(1))

        # Extract gas used
        gas_match = re.search(r'gas:\s*(\d+)', stdout)
        if gas_match:
            result['gas_used'] = int(gas_match.group(1))

        # Extract balance changes
        initial_match = re.search(r'Initial Balance:\s*(\d+)', stdout)
        final_match = re.search(r'Final Balance:\s*(\d+)', stdout)

        if initial_match and final_match:
            result['initial_balance'] = int(initial_match.group(1))
            result['final_balance'] = int(final_match.group(1))

        # Check for revert
        if 'revert' in stdout.lower() or 'revert' in stderr.lower():
            result['reverted'] = True
        else:
            result['reverted'] = False

        return result

    def cleanup(self):
        """Clean up generated files."""
        # Optionally remove generated test files
        pass
