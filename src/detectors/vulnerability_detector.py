"""
Vulnerability detection module.

Implements pattern-based detection for common smart contract vulnerabilities
including reentrancy, overflow/underflow, access control issues, and more.
"""

import re
from typing import Dict, List, Set
from pathlib import Path


class VulnerabilityDetector:
    """
    Detects common smart contract vulnerabilities through pattern matching
    and code analysis.
    """

    def __init__(self):
        """Initialize vulnerability detector with pattern definitions."""
        self.vulnerability_patterns = self._initialize_patterns()

    def _initialize_patterns(self) -> Dict:
        """
        Initialize vulnerability detection patterns.

        Returns:
            Dictionary of vulnerability patterns
        """
        return {
            'reentrancy': {
                'patterns': [
                    r'\.call\{value:',
                    r'\.call\.value\(',
                    r'\.transfer\(',
                    r'\.send\(',
                ],
                'severity': 'critical',
                'description': 'Potential reentrancy vulnerability detected'
            },
            'unchecked_call': {
                'patterns': [
                    r'\.call\(',
                    r'\.delegatecall\(',
                ],
                'severity': 'high',
                'description': 'Unchecked low-level call return value'
            },
            'tx_origin': {
                'patterns': [
                    r'tx\.origin',
                ],
                'severity': 'high',
                'description': 'Use of tx.origin for authentication is unsafe'
            },
            'block_timestamp': {
                'patterns': [
                    r'block\.timestamp',
                    r'now',
                ],
                'severity': 'medium',
                'description': 'Block timestamp manipulation possible'
            },
            'selfdestruct': {
                'patterns': [
                    r'selfdestruct\(',
                    r'suicide\(',
                ],
                'severity': 'critical',
                'description': 'Unprotected selfdestruct found'
            },
            'delegatecall': {
                'patterns': [
                    r'\.delegatecall\(',
                ],
                'severity': 'high',
                'description': 'Dangerous delegatecall usage detected'
            },
            'uninitialized_storage': {
                'patterns': [
                    r';\s*\n\s*function.*{\s*\n\s*address\s+\w+;',
                ],
                'severity': 'medium',
                'description': 'Potentially uninitialized storage pointer'
            },
            'floating_pragma': {
                'patterns': [
                    r'pragma\s+solidity\s*\^',
                ],
                'severity': 'low',
                'description': 'Floating pragma - lock to specific version'
            },
            'outdated_solidity': {
                'patterns': [
                    r'pragma\s+solidity\s+[<>=]*\s*0\.[0-7]\.',
                ],
                'severity': 'high',
                'description': 'Outdated Solidity version detected'
            },
            'missing_zero_check': {
                'patterns': [
                    r'function\s+\w+.*address\s+\w+.*{(?!.*require\(.*!=.*address\(0\))',
                ],
                'severity': 'medium',
                'description': 'Missing zero address validation'
            }
        }

    def detect(self, contract_path: str, existing_results: Dict) -> List[Dict]:
        """
        Detect vulnerabilities in a contract.

        Args:
            contract_path: Path to the Solidity contract
            existing_results: Results from other analyzers

        Returns:
            List of detected vulnerabilities
        """
        try:
            # Read contract code
            with open(contract_path, 'r') as f:
                contract_code = f.read()

            vulnerabilities = []

            # Pattern-based detection
            pattern_vulns = self._detect_patterns(contract_code, contract_path)
            vulnerabilities.extend(pattern_vulns)

            # Analyze results from other tools
            tool_vulns = self._analyze_tool_results(existing_results)
            vulnerabilities.extend(tool_vulns)

            # Advanced detection
            advanced_vulns = self._advanced_detection(contract_code, contract_path)
            vulnerabilities.extend(advanced_vulns)

            # Deduplicate
            vulnerabilities = self._deduplicate(vulnerabilities)

            return vulnerabilities

        except Exception as e:
            print(f"Error in vulnerability detection: {str(e)}")
            return []

    def _detect_patterns(self, contract_code: str, contract_path: str) -> List[Dict]:
        """
        Detect vulnerabilities using pattern matching.

        Args:
            contract_code: Source code to analyze
            contract_path: Path to the contract file

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []

        for vuln_type, vuln_info in self.vulnerability_patterns.items():
            for pattern in vuln_info['patterns']:
                matches = re.finditer(pattern, contract_code, re.MULTILINE)

                for match in matches:
                    # Calculate line number
                    line_num = contract_code[:match.start()].count('\n') + 1

                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': vuln_info['severity'],
                        'description': vuln_info['description'],
                        'line': line_num,
                        'code_snippet': self._get_code_snippet(contract_code, match.start()),
                        'file': contract_path,
                        'detector': 'pattern_matcher'
                    })

        return vulnerabilities

    def _analyze_tool_results(self, existing_results: Dict) -> List[Dict]:
        """
        Analyze and consolidate results from other tools.

        Args:
            existing_results: Results from Slither, Mythril, etc.

        Returns:
            List of vulnerabilities from tools
        """
        vulnerabilities = []

        # Process Slither results
        slither = existing_results.get('analyzers', {}).get('slither', {})
        for detector in slither.get('detectors', []):
            vulnerabilities.append({
                'type': detector.get('check', 'unknown'),
                'severity': detector.get('severity', 'medium'),
                'description': detector.get('description', ''),
                'detector': 'slither',
                'confidence': detector.get('confidence', 'unknown')
            })

        # Process Mythril results
        mythril = existing_results.get('analyzers', {}).get('mythril', {})
        for issue in mythril.get('issues', []):
            vulnerabilities.append({
                'type': issue.get('title', 'unknown'),
                'severity': issue.get('severity', 'medium'),
                'description': issue.get('description', ''),
                'line': issue.get('lineno', 0),
                'detector': 'mythril',
                'swc_id': issue.get('swc_id', '')
            })

        return vulnerabilities

    def _advanced_detection(self, contract_code: str, contract_path: str) -> List[Dict]:
        """
        Perform advanced vulnerability detection.

        Args:
            contract_code: Source code to analyze
            contract_path: Path to the contract file

        Returns:
            List of detected vulnerabilities
        """
        vulnerabilities = []

        # Check for reentrancy with state changes
        if self._check_reentrancy_pattern(contract_code):
            vulnerabilities.append({
                'type': 'reentrancy_complex',
                'severity': 'critical',
                'description': 'State changes after external call detected - classic reentrancy pattern',
                'detector': 'advanced_detector',
                'file': contract_path
            })

        # Check for integer overflow (pre-0.8.0)
        if self._check_overflow_risk(contract_code):
            vulnerabilities.append({
                'type': 'integer_overflow',
                'severity': 'high',
                'description': 'Potential integer overflow in unchecked arithmetic',
                'detector': 'advanced_detector',
                'file': contract_path
            })

        # Check for unprotected ether withdrawal
        if self._check_unprotected_withdrawal(contract_code):
            vulnerabilities.append({
                'type': 'unprotected_withdrawal',
                'severity': 'critical',
                'description': 'Unprotected function allows arbitrary ether withdrawal',
                'detector': 'advanced_detector',
                'file': contract_path
            })

        # Check for missing event emissions
        if self._check_missing_events(contract_code):
            vulnerabilities.append({
                'type': 'missing_events',
                'severity': 'low',
                'description': 'Critical functions missing event emissions',
                'detector': 'advanced_detector',
                'file': contract_path
            })

        return vulnerabilities

    def _check_reentrancy_pattern(self, code: str) -> bool:
        """Check for reentrancy vulnerability pattern."""
        # Look for: external call followed by state change
        pattern = r'\.call.*\n.*=.*'
        return bool(re.search(pattern, code, re.MULTILINE))

    def _check_overflow_risk(self, code: str) -> bool:
        """Check for integer overflow risk."""
        # Check if using Solidity < 0.8.0 without SafeMath
        has_old_version = bool(re.search(r'pragma\s+solidity\s+[<>=]*\s*0\.[0-7]\.', code))
        has_safemath = 'SafeMath' in code
        has_arithmetic = bool(re.search(r'[+\-*/]', code))

        return has_old_version and not has_safemath and has_arithmetic

    def _check_unprotected_withdrawal(self, code: str) -> bool:
        """Check for unprotected ether withdrawal."""
        # Look for transfer/send/call without access control
        withdrawal_pattern = r'function\s+\w+[^{]*{[^}]*\.(?:transfer|send|call\{value)'
        access_control_pattern = r'(?:require|modifier|onlyOwner)'

        functions = re.findall(withdrawal_pattern, code, re.DOTALL)
        for func in functions:
            if not re.search(access_control_pattern, func):
                return True
        return False

    def _check_missing_events(self, code: str) -> bool:
        """Check for missing event emissions in critical functions."""
        # Look for state-changing functions without events
        critical_keywords = ['owner', 'transfer', 'withdraw', 'pause']

        for keyword in critical_keywords:
            func_pattern = rf'function\s+\w*{keyword}\w*[^{{]*{{[^}}]*'
            functions = re.findall(func_pattern, code, re.IGNORECASE | re.DOTALL)

            for func in functions:
                if '=' in func and 'emit' not in func:
                    return True
        return False

    def _get_code_snippet(self, code: str, position: int, context_lines: int = 2) -> str:
        """
        Extract code snippet around a position.

        Args:
            code: Full source code
            position: Character position
            context_lines: Number of lines to show before/after

        Returns:
            Code snippet
        """
        lines = code[:position].split('\n')
        line_num = len(lines) - 1

        all_lines = code.split('\n')
        start = max(0, line_num - context_lines)
        end = min(len(all_lines), line_num + context_lines + 1)

        snippet = '\n'.join(all_lines[start:end])
        return snippet

    def _deduplicate(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """
        Remove duplicate vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities

        Returns:
            Deduplicated list
        """
        seen: Set[str] = set()
        unique = []

        for vuln in vulnerabilities:
            # Create unique key
            key = f"{vuln.get('type')}_{vuln.get('line', 0)}_{vuln.get('severity')}"

            if key not in seen:
                seen.add(key)
                unique.append(vuln)

        return unique
