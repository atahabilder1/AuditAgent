"""
Exploit code generator using LLM and templates.

Generates working Solidity exploit contracts that can be tested
in a sandboxed environment to validate vulnerabilities.
"""

import logging
import os
from typing import Dict, Optional, List
from pathlib import Path
from rich.console import Console

console = Console()
logger = logging.getLogger(__name__)


class ExploitGenerator:
    """
    Generates exploit code for detected vulnerabilities.

    Uses LLM (Qwen) to generate working Solidity exploits based on
    vulnerability analysis and predefined templates.
    """

    def __init__(self, llm_client=None):
        """
        Initialize exploit generator.

        Args:
            llm_client: OllamaClient instance (optional)
        """
        self.llm_client = llm_client
        self.templates_dir = Path(__file__).parent / 'templates'

    def generate_exploit(
        self,
        vulnerability: Dict,
        contract_code: str,
        contract_address: Optional[str] = None,
        chain: str = 'bsc'
    ) -> Dict:
        """
        Generate exploit code for a vulnerability.

        Args:
            vulnerability: Vulnerability details
            contract_code: Target contract source code
            contract_address: Optional contract address
            chain: Target blockchain

        Returns:
            Dictionary with exploit code and metadata
        """
        vuln_type = vulnerability.get('type', 'unknown').lower()

        console.print(f"[yellow]Generating exploit for: {vuln_type}[/yellow]")

        # Try to use template first
        template_exploit = self._generate_from_template(
            vuln_type,
            vulnerability,
            contract_address
        )

        if template_exploit:
            console.print("[green]Generated exploit from template[/green]")
            return {
                'success': True,
                'exploit_code': template_exploit,
                'method': 'template',
                'vulnerability_type': vuln_type
            }

        # Fall back to LLM generation
        if self.llm_client:
            console.print("[yellow]Generating exploit using LLM...[/yellow]")
            llm_exploit = self._generate_with_llm(
                vulnerability,
                contract_code,
                chain
            )

            if llm_exploit.get('success'):
                console.print("[green]Generated exploit using LLM[/green]")
                return llm_exploit

        # Fallback: return template with placeholders
        console.print("[yellow]Using base template with placeholders[/yellow]")
        base_template = self._get_base_template(contract_address)

        return {
            'success': False,
            'exploit_code': base_template,
            'method': 'base_template',
            'vulnerability_type': vuln_type,
            'error': 'Could not generate specific exploit, using base template'
        }

    def _generate_from_template(
        self,
        vuln_type: str,
        vulnerability: Dict,
        contract_address: Optional[str]
    ) -> Optional[str]:
        """
        Generate exploit from predefined template.

        Args:
            vuln_type: Vulnerability type
            vulnerability: Vulnerability details
            contract_address: Target contract address

        Returns:
            Exploit code or None
        """
        template_map = {
            'reentrancy': 'reentrancy.sol',
            'flash_loan': 'flash_loan.sol',
            'price_manipulation': 'price_manipulation.sol',
            'access_control': 'access_control.sol',
            'arbitrage': 'flash_loan.sol',  # Use flash loan template
        }

        template_file = template_map.get(vuln_type)
        if not template_file:
            return None

        template_path = self.templates_dir / template_file
        if not template_path.exists():
            logger.warning(f"Template not found: {template_path}")
            return None

        try:
            with open(template_path, 'r') as f:
                template = f.read()

            # Replace placeholders
            exploit_code = template.replace(
                '{{CONTRACT_ADDRESS}}',
                contract_address or '0x0000000000000000000000000000000000000000'
            )
            exploit_code = exploit_code.replace(
                '{{DESCRIPTION}}',
                vulnerability.get('description', 'Unknown vulnerability')
            )

            return exploit_code

        except Exception as e:
            logger.error(f"Failed to load template: {e}")
            return None

    def _generate_with_llm(
        self,
        vulnerability: Dict,
        contract_code: str,
        chain: str
    ) -> Dict:
        """
        Generate exploit using LLM.

        Args:
            vulnerability: Vulnerability details
            contract_code: Target contract code
            chain: Target blockchain

        Returns:
            Dictionary with LLM-generated exploit
        """
        if not self.llm_client:
            return {'success': False, 'error': 'LLM client not available'}

        try:
            response = self.llm_client.generate_exploit(
                contract_code,
                vulnerability,
                chain
            )

            if response.get('success'):
                from ..llm.response_parser import ResponseParser
                parsed = ResponseParser.parse_exploit_code(response['content'])

                return {
                    'success': parsed['is_valid_solidity'],
                    'exploit_code': parsed['exploit_code'],
                    'method': 'llm',
                    'vulnerability_type': vulnerability.get('type'),
                    'has_verify_function': parsed['has_verify_function']
                }
            else:
                return {
                    'success': False,
                    'error': response.get('error', 'LLM generation failed')
                }

        except Exception as e:
            logger.error(f"LLM exploit generation failed: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def _get_base_template(self, contract_address: Optional[str]) -> str:
        """
        Get base exploit template.

        Args:
            contract_address: Target contract address

        Returns:
            Base template code
        """
        base_path = self.templates_dir / 'base.sol'

        if base_path.exists():
            with open(base_path, 'r') as f:
                template = f.read()
            return template.replace(
                '{{CONTRACT_ADDRESS}}',
                contract_address or '0x0000000000000000000000000000000000000000'
            )

        # Inline fallback
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ITarget {{
    // Add target contract interface here
}}

contract FlawVerifier {{
    address public target;
    address public owner;

    constructor(address _target) {{
        target = _target;
        owner = msg.sender;
    }}

    function verify() external returns (bool) {{
        // Exploit logic goes here
        // Return true if exploit succeeds

        return false;  // TODO: Implement exploit
    }}

    receive() external payable {{}}
}}
'''

    def save_exploit(
        self,
        exploit_code: str,
        output_path: str,
        metadata: Optional[Dict] = None
    ) -> str:
        """
        Save exploit code to file.

        Args:
            exploit_code: Exploit Solidity code
            output_path: Path to save file
            metadata: Optional metadata to include

        Returns:
            Path to saved file
        """
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        # Add metadata as comments
        if metadata:
            header = f"""// Exploit generated by AuditAgent v2.0
// Vulnerability: {metadata.get('vulnerability_type', 'unknown')}
// Method: {metadata.get('method', 'unknown')}
// Generated: {metadata.get('timestamp', 'unknown')}

"""
            full_code = header + exploit_code
        else:
            full_code = exploit_code

        with open(output_file, 'w') as f:
            f.write(full_code)

        console.print(f"[green]Exploit saved to: {output_file}[/green]")
        return str(output_file)

    def generate_multiple_exploits(
        self,
        vulnerabilities: List[Dict],
        contract_code: str,
        output_dir: str,
        chain: str = 'bsc'
    ) -> List[Dict]:
        """
        Generate exploits for multiple vulnerabilities.

        Args:
            vulnerabilities: List of vulnerabilities
            contract_code: Target contract code
            output_dir: Directory to save exploits
            chain: Target blockchain

        Returns:
            List of exploit generation results
        """
        results = []

        for i, vuln in enumerate(vulnerabilities, 1):
            console.print(f"\n[cyan]Generating exploit {i}/{len(vulnerabilities)}[/cyan]")

            exploit = self.generate_exploit(
                vuln,
                contract_code,
                vuln.get('contract_address'),
                chain
            )

            if exploit.get('success'):
                # Save to file
                output_path = f"{output_dir}/exploit_{i}_{vuln.get('type', 'unknown')}.sol"
                saved_path = self.save_exploit(
                    exploit['exploit_code'],
                    output_path,
                    {
                        'vulnerability_type': vuln.get('type'),
                        'method': exploit.get('method'),
                        'timestamp': vuln.get('timestamp', '')
                    }
                )

                exploit['saved_path'] = saved_path

            results.append(exploit)

        return results
